## JS中的8种数据类型及区别
### 基本类型（值类型）：
Number(数字)、String(字符串)、Boolean(布尔)、Symbol(符号)、null(空)、undefined(未定义) 栈中
### 引用类型(复杂数据类型)：
Object(对象)、Function(函数)、Array(数组)、Data(日期)等 堆中

## JS中的数据类型检测方案
### typeof
* 优点：能够快速区分基本数据类型
* 缺点：不能将Object、array和Null区分，都返回object

### instanceof 
* 优点：能够区分array、Object和function，适合用于判断自定义的类实例对象
* 缺点：Number,Boolean,String基本数据类型不能判断

### Object.proptype.toString.call()
* 优点：精准判断数据类型
* 缺点：写法繁琐不容易记，推荐进行封装后使用

## 什么是虚值和真值？分别有哪些？
* 定义：虚值和真值分别对应 布尔类型 的 false和true
+ 虚值：1.长度为 0 的字符串，2.数字0，3.false，4.undefined，5.null，6.NaN
+ 真值：1.空数组，2.空对象，3.其他

## number能表示的整数的最大范围
15位以下

## 查询某个对象是否有某个属性的方法
1. in 关键字
2. undefined 判断是否为undefined，无法判断 undefined属性
3. hasOwnProperty() 判断自有属性 ，无法判断继承属性

## ==和===区别
1. === 是严格相等，要求数据类型和值都要相等
2. == 会发生隐式转换，把比较的两个值转换成相同的数据类型，再进行比较值

## var && let(es6) && const(es6)
* var 有变量提升，let、const没有 （可以先使用后声明）
* var 允许声明同名变量， let、const不允许 
* var 会挂载到 window 对象上
* const 用来定义常量，使用时必须赋值，且不能修改
|区别				|var|let|const	|
|--					|--	|--	|--		|
|是否有块级作用域		|否	|是	|是		|
|是否存在变量提升		|是	|否	|否		|
|是否添加全局属性		|是	|否	|否		|
|能否重复声明变量		|是	|否	|否		|
|是否存在暂时性死区	|否	|是	|是		|
|是否必须设置初始值	|否	|否	|是		|
|能否改变指针指向		|是	|否	|否		|


## JS垃圾回收机制
* 目的：释放内存
### 标记清除法
chrome 使用标记清除法的修改版
### 引用计数法

## 作用域和作用域链
### 作用域
* 定义：函数可访问变量对象的范围 （包括变量及其他资源）
* 作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。
* 注意：js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了

### 作用域链
* 定义：一般情况下，变量到 创建该变量 的函数的作用域中取值。
* 但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

## 闭包
* 自己的话 ：外层函数执行完毕并销毁后，返回的内层函数仍可访问父级函数作用域定义的变量
* 原理：内层函数的执行上下文中的 [[spoce]] 作用域链中保存了外层函数的活动对象 AO
* 应用：埋点计数器、柯里化
* 缺点：内存泄漏

## JS 中 this 的五种情况
* 1.作为普通函数执行时，this 指向 window
* 2.当函数作为对象的方法被调用时，this 就会指向该对象
* 3.构造器调用，this 指向 返回的这个对象
* 4.箭头函数 箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。

## 原型 && 原型链
### 原型关系
* 每个 class 都有显式原型 protoType和隐式原型 _proto_
* 每个实例都有隐式原型 _proto_
* 实例的_proto_指向对应 class 的 prototype 

### 原型
* 定义：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性，其实就是 prototype 对象。

### 原型链
* 定义：由相互关联的原型组成的链状结构就是原型链。

## new运算符的实现机制
* 1.首先创建了一个新的空对象 const a = new Object()
* 2.设置原型，将对象的原型设置为构造函数的 prototype 对象 a._proto_ =  context.prototype
* 3.让构造函数的 this 指向 新对象 let res =  context.apply(a,[...arguments].slice(1))
* 4.判断返回值 res 是否是引用类型，是返回 res，否返回 新对象 a

## 浏览器中的事件循环（EventLoop）
1. 代码开始执行，创建一个全局调用栈，script作为宏任务执行 
2. 执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列
3. 同步任务执行完毕，查看微任务队列
	* 若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)
	* 若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空

## this指向类型
1. 默认绑定：非严格模式下 this 指向全局对象，严格模式下 this 会绑定为 undefined
2. 满足 XXX.fn() 格式，fn 的 this 指向 XXX。如果存在链式调用， this 永远指向最后调用它的那个对象
3. 显式绑定: 通过 call/apply/bind 修改 this 指向
4. new绑定: 通过 new 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 this 
5. 箭头函数绑定: 箭头函数没有 this ，它的 this 是通过作用域链查到外层作用域的 this ，且指向函数定义时的 this 而非执行时

## JS原型链继承与Class继承
1. JS原型链继承 类似 new 核心是通过 parent.call(this) 对子类添加属性，再将子类的 proto 指向 new parent()
2. 基于Class继承 核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super继承父类属性和方法。

## cookie、localStorage、sessionStorage 的区别
从 生命周期、存放数据大小、http请求、易用性
1. cookie
	* 可设置失效时间，默认关闭浏览器失效
	* 4k大小
	* 每次http请求都会放到请求头中，保存太多数据会有性能问题
	* 原生 api 操作不友好
2. localStorage
	* 除非自动清除，否则永久保存
	* 5mb 大小
	* 仅在客户端（即浏览器）中保存，不参与和服务器的通信
	* 更好的api支持 ，setItem 和 getItem
3. sessionStorage
	* 关闭页面或浏览器清除
	* 5mb 大小
	* 仅在客户端（即浏览器）中保存，不参与和服务器的通信
	* 更好的api支持 ，setItem 和 getItem

## 防抖和节流的区别
1. 防抖：短期多次操作只在最后一次确定执行 
2. 节流：一段时间内只执行一次

## 箭头函数和普通函数的区别
1. 箭头函数没有自己的 this ，使用this会指向上层作用域中this的指向
2. 箭头函数不能用作构造函数，不能对他使用 new
3. 不能用call/apply/bind修改this指向，但可以通过修改外层作用域的this来间接修改
4. 没有 protoType 属性
5. 没有 arguments 对象

## 可以说一下你对解构的理解吗
* 解构是ES6新增的语法，我们通常是使用解构从对象中解构出一个变量
* 如果这个变量在对象中不存在，会返回一个undefined，如果存在将会返回正确的值
* ps：解构可以重命名 const {a:aName} = obj

## 数组常用方法
* pop() 删除 最后一项
* shift() 删除 最后一项
* unshift() 删除 第一项
* map() 循环数组，具有返回值， 不会对原数组造成影响 可以自由组合返回值
* filter() 筛选数组，具有返回值， 不会对原数组造成影响 根据判断条件返回
* forEach 循环数组，对原数组会造成影响 遍历的时候修改原数组的值
* splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组）
* slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。

## 